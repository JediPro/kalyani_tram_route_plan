---
title: "Kolkata Lit Meet Schedule"
author: "Pratik C"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE, 
                      fig.width = 12, fig.height = 12,
                      echo = TRUE, eval = TRUE)
options(warn = 1)
```

```{r Set environment}
# Load libraries
library(tidyverse)
library(hrbrthemes)
library(lubridate)
library(scales)
library(ggtext)
library(sf)
library(ggrepel)
library(ggpp)
library(ggforce)
library(gg.layers)
library(ggalt)
library(patchwork)
library(ggfittext)
library(rvest)
library(osmdata)
library(terra)
library(GA)

# Load themes script
source(file = "C:\\Stuff\\Datasets\\vaw_themes.R")

# Set working directory
setwd("C:\\Stuff\\Datasets\\GitHub\\kalyani_tram_route_plan\\")
```

## Existing Tram Networks

```{r Existing Tram Networks}

# Read in city populations -------------------------------------
# Not usiong this as the names are in Unicode, which is difficult to map to ascii names in Wiki file
# Downloaded from https://unstats.un.org/unsd/demographic-social/products/dyb/documents/DYB2024/table08.xls
# table_city_pop <- readxl::read_xlsx(path = "city_pop.xlsx", sheet = "Data", 
#                                     trim_ws = FALSE, skip = 6,
#                                     col_types = c("text", "numeric", "skip", "numeric",
#                                                   "skip", "numeric", "skip", "numeric",
#                                                   "skip", "numeric", "skip", "numeric", 
#                                                   "skip", "numeric", "skip", "numeric", 
#                                                   "skip"),
#                                     col_names = c("territory", "city_pop_total", 
#                                                   "city_pop_male", "city_pop_female",
#                                                   "city_area",
#                                                   "urban_pop_total", "urban_pop_male", 
#                                                   "urban_pop_female", "urban_area")) %>% 
#   # First, extract the year of the estimate for each country
#   mutate(estimate_year = str_extract(string = territory, pattern = "\\d{4}"),
#          # Flag rows containing cities, which are the ones having some values
#          city_flag = !(is.na(city_pop_total) & is.na(urban_pop_total)),
#          continent_flag = (toupper(territory) == territory) & (!city_flag) & (is.na(estimate_year)),
#          country_flag = (!city_flag) & (!continent_flag) & (is.na(estimate_year)),
#          # Create columns for continent and country
#          continent = case_when(continent_flag ~ territory),
#          country = case_when(country_flag ~ territory)) %>% 
#   # Fill values
#   fill(continent, country, estimate_year, .direction = "down") %>% 
#   # Keep only rows for cities
#   filter(city_flag) %>% 
#   # Remove helper columns
#   select(-contains("flag")) %>% 
#   # Clean country and continent names
#   mutate(across(.cols = c(country, continent), 
#                 .fns = ~str_replace_all(string = .x, pattern = "-.*|\\d", 
#                                         replacement = "")),
#          # Remove brackets
#          territory = str_replace_all(string = territory, pattern = "\\(.*", replacement = "") %>% trimws())

# Fetch list of tram and metro systems ---------------------------
table_lrt_systems <- read_html("https://en.wikipedia.org/wiki/List_of_tram_and_light_rail_transit_systems") %>% 
  # Reqad in all tables in the file
  html_table(header = TRUE) %>% 
  # convert to tibble for easier wrangling
  as_tibble_col(column_name = "tbl") %>% 
  # Extract number of columns in each table
  mutate(num_col = map_int(.x = tbl, .f = ncol)) %>% 
  # Keep only tables with at least 8 columns, as they correspond to data we need
  filter(num_col >= 8) %>% 
  # Unnest all
  select(-num_col) %>% 
  # Convert to character all columns in the files
  mutate(tbl = map(.x = tbl, .f = as_tibble),
         # Rename a column in one of the files
         tbl = map(.x = tbl, .f = function(x){ x %>% 
             rename(Stations = c(contains("Stations")))}),
         tbl = map(.x = tbl, .f = function(x){ x %>% 
             mutate(across(.cols = c(Stations,  Lines), .fns = as.character))})) %>% 
  unnest(cols = tbl) %>% 
  # Rename columns
  rename(city = Location, country = Country, system = System, year = `Year opened`,
         stations = Stations, lines = Lines, length = `System length`,
         type = Type, ridership = `Annual ridership(millions)`) %>% 
  # Process fields
  mutate(across(.cols = everything(), 
                .fns = ~str_replace_all(string = .x, pattern = "\\[.*|,.*", 
                                        replacement = "")),
         # Convert to numeric
         across(.cols = c(year, stations, lines), 
                .fns = ~str_extract(string = .x, pattern = "\\d.*") %>% as.integer()),
         length = str_extract(string = length, pattern = "(.*)[\\h]km", group = 1) %>% as.numeric()) %>% 
  drop_na(year) %>% 
  # rename Washington
  mutate(city = case_when(city == "Washington" ~ "Washington DC", TRUE ~ city),
         city = trimws(city)) %>% 
  # Remove cities which only have heritage trams
  filter(str_detect(string = type, pattern = "^Heritage.*", negate = TRUE))

# Fetch list of cities with metro systems ----------------------------------------
table_metro_systems <- read_html("https://en.wikipedia.org/wiki/List_of_metro_systems") %>% 
  # Reqad in all tables in the file
  html_table(header = TRUE) %>% 
  # convert to tibble for easier wrangling
  as_tibble_col(column_name = "tbl") %>% 
  # Extract number of columns in each table
  mutate(num_col = map_int(.x = tbl, .f = ncol)) %>% 
  # Keep only tables with at least 8 columns, as they correspond to data we need
  filter(num_col >= 8) %>% 
  # Unnest all
  select(-num_col) %>% 
  # Convert to character all columns in the files
  mutate(tbl = map(.x = tbl, .f = as_tibble),
         # Rename a column in one of the files
         tbl = map(.x = tbl, .f = function(x){ x %>% 
             rename(Stations = c(contains("Stations")))})) %>% 
  unnest(cols = tbl) %>% 
  # Rename columns
  rename(city = City, country = Country, system = Name, year_open = `Serviceopened`,
         last_expansion = `Lastexpanded`, stations = Stations, 
         length = `System length`, ridership = `Annual ridership(millions)`) %>% 
  # Process fields
  mutate(across(.cols = everything(), 
                .fns = ~str_replace_all(string = .x, pattern = "\\[.*|,.*", 
                                        replacement = "")),
         # Convert to numeric
         across(.cols = c(year_open, last_expansion, stations), 
                .fns = ~str_extract(string = .x, pattern = "\\d.*") %>% as.integer()),
         length = str_extract(string = length, pattern = "(.*)[\\h]km", group = 1) %>% as.numeric(),
         # Recode city
         city = case_match(.x = city, 
                           "Washington" ~ "Washington DC",
                           "San Francisco (Bay Area)" ~ "San Francisco",
                           "Taipei" ~ "New Taipei",
                           "Copenhagen" ~ "Greater Copenhagen",
                           .default = city),
         # Convert to upper
         across(c(city, country), toupper))

# Download world cities database from simplemaps to map ascii names to unicode names --------------------
table_city_name <- readxl::read_xlsx(path = "worldcities.xlsx") %>% 
  # Recode country names that do not match Popn table
  mutate(country = case_match(.x = country, "Korea, North" ~ "North Korea",
                              "Czechia" ~ "Czech Republic",
                              .default = country),
         city_ascii = case_when(city_ascii == "Washington" & admin_name == "District of Columbia" ~ "Washington DC",
                                TRUE ~ city_ascii),
         city = case_when(city == "Washington" & admin_name == "District of Columbia" ~ "Washington DC",
                                TRUE ~ city),
         popn = population,
         across(c(city, city_ascii, country), toupper)) %>% 
  # Some city names are duplicated, keep only the entry per city-country with highest popn
  group_by(city_ascii, country) %>% 
  slice_max(order_by = population, n = 1) %>% ungroup() %>% 
  # Recode city names
  mutate(city_ascii = case_match(.x = city_ascii,
                                 "AR RAYYAN" ~ "AL RAYYAN",
                                "BRANDENBURG" ~ "BRANDENBURG AN DER HAVEL",
                                "CH'ONGJIN" ~ "CHONGJIN",
                                "ERFURT" ~ "ERFURT",
                                "FRANKFURT" ~ "FRANKFURT AM MAIN",
                                "GALATI" ~ "GALAȚI",
                                "GENT" ~ "GHENT",
                                "COPENHAGEN" ~ "GREATER COPENHAGEN",
                                "HANNOVER" ~ "HANOVER",
                                "IASI" ~ "IAȘI",
                                "KAMAKURAYAMA" ~ "KAMAKURA",
                                "KATOWICE" ~ "KATOWICE AND ITS AREA",
                                "KRASNOTUR'INSK" ~ "KRASNOTURYINSK",
                                "LUZHANG" ~ "LIJIANG",
                                "MINNEAPOLIS" ~ "MINNEAPOLIS–SAINT PAUL",
                                "NABEREZHNYYE CHELNY" ~ "NABEREZHNYE CHELNY",
                                "TAIPEI" ~ "NEW TAIPEI",
                                "NEWCASTLE" ~ "NEWCASTLE UPON TYNE",
                                "NIZHNIY NOVGOROD" ~ "NIZHNY NOVGOROD",
                                "NIZHNIY TAGIL" ~ "NIZHNY TAGIL",
                                "NAVAPOLATSK" ~ "NOVOPOLOTSK",
                                "OREL" ~ "ORYOL",
                                "PADOVA" ~ "PADUA",
                                "PLOIESTI" ~ "PLOIEȘTI",
                                "PORT LOUIS" ~ "PORT LOUIS AND THE DISTRICT OF PLAINES WILHEMS",
                                "RESITA" ~ "REȘIȚA",
                                "ROSTOV" ~ "ROSTOV-ON-DON",
                                "SANTA CRUZ" ~ "SANTA CRUZ DE TENERIFE",
                                "SANTOS" ~ "SANTOS AND THE METROPOLITAN REGION OF BAIXADA SANTISTA",
                                "SEVILLA" ~ "SEVILLE",
                                "STARYY OSKOL" ~ "STARY OSKOL",
                                "TEL AVIV-YAFO" ~ "TEL AVIV",
                                "TIMISOARA" ~ "TIMIȘOARA",
                                "USOL'YE-SIBIRSKOYE" ~ "USOLYE-SIBIRSKOYE",
                                "VITSYEBSK" ~ "VITEBSK",
                                "YEVPATORIIA" ~ "YEVPATORIA",
                                "KOCAELI" ~ "İZMIT", 
                                .default = city_ascii
))

# Create table combining system and population information -----------------------
data_lrt_pop <- table_lrt_systems %>% 
  # Some cities have multiple rows, sum up the values for them
  group_by(city, country) %>% 
  summarise(across(.cols = c(stations, lines, length), 
                   .fns = ~sum(.x, na.rm = TRUE)),
            .groups = "drop") %>% 
  mutate(across(c(city, country), toupper)) %>% 
  # Map popn to ascii codes city
  left_join(y = table_city_name %>% select(city_ascii, country, popn),
            by = c("city" = "city_ascii", "country")) %>% 
  # Remove cities which also have metro systems, to get closer estimates
  left_join(y = table_city_name %>% select(city, country, popn),
            by = c("city", "country"), suffix = c("_1", "_2")) %>% 
  # Get length of metro systems for cities which have them
  anti_join(y = table_metro_systems %>% distinct(city, country),
            by = c("city", "country")) %>% 
  # Consider overlap in population columns
  mutate(popn = case_when(is.na(popn_1) ~ popn_2, TRUE ~ popn_1),
         # Fill in populations for missing cities manually
         popn = case_match(.x = city,
                           "BAD SCHANDAU" ~ 3409,
                          "BELGIAN COAST" ~ 219488,
                          "CHERYOMUSHKI" ~ 10000,
                          "DESSAU" ~ 67747,
                          "ERFURT" ~ 216000,
                          "HUDSON COUNTY" ~ 724854,
                          "LUND" ~ 94393,
                          "LUSAIL" ~ 198600,
                          "MENGZI" ~ 585976,
                          "OSINNIKI" ~ 40000,
                          "QIUBEI" ~ 468172,
                          "TIANSHUI" ~ 1212791,
                          "VOLCHANSK" ~ 8000,
                          "VOLZHSKY" ~ 321427,
                          .default = popn)) %>% 
  # Remove helper columns
  select(-popn_1, -popn_2) %>% 
  # Replace 0 in stations and lines with NA
  mutate(across(.cols = c(stations, lines), ~na_if(x = .x, y = 0))) 
```

## Visualize relations between route characteristics and city population

```{r Routes vs Population}
# Length vs Stations --------------------------------
# Plot
plot_length_stations <- data_lrt_pop %>% 
  # plot
  ggplot() +
  # points
  geom_point(mapping = aes(x = length, y = stations), size = 2, 
             alpha = 0.8, colour = "firebrick") +
  geom_smooth(mapping = aes(x = length, y = stations), linewidth = 1,
              colour = "dodgerblue", alpha = 0.2, fill = "dodgerblue", 
              method = "lm") +
  # Scales
  scale_x_continuous(name = "Route Length (km)", 
                     expand = expansion(mult = c(0.01, 0.01)), trans = "log10") +
  scale_y_continuous(name = "Stations", 
                     expand = expansion(mult = c(0.01, 0.01)), trans = "log10") +
  # Labels
  labs(title = "Stations vs Route Length") +
  theme_vaw_dark()
# Show plot
plot_length_stations
# Model Length vs Stations
mod_length_stations <- lm(formula = log10(stations) ~ log10(length), 
                          data = data_lrt_pop, na.action = na.omit)
# R-squared
yardstick::rsq_trad_vec(truth = mod_length_stations$model$`log10(stations)`, 
                        estimate = mod_length_stations$fitted.values)
# Prediction
10^(mod_length_stations$coefficients[1] + (mod_length_stations$coefficients[2] * log10(20)))

# Length vs Lines --------------------------------
# Plot
plot_length_lines <- data_lrt_pop %>% 
  # plot
  ggplot() +
  # points
  geom_point(mapping = aes(x = length, y = lines), size = 2, 
             alpha = 0.8, colour = "firebrick") +
  geom_smooth(mapping = aes(x = length, y = lines), linewidth = 1,
              colour = "dodgerblue", alpha = 0.2, fill = "dodgerblue", 
              method = "lm") +
  # Scales
  scale_x_continuous(name = "Route Length (km)", 
                     expand = expansion(mult = c(0.01, 0.01)), trans = "log10") +
  scale_y_continuous(name = "Lines", 
                     expand = expansion(mult = c(0.01, 0.01)), trans = "log10") +
  # Labels
  labs(title = "Lines vs Route Length") +
  theme_vaw_dark()
# Show plot
plot_length_lines
# Model Length vs Stations
mod_length_lines <- lm(formula = log10(lines) ~ log10(length), 
                          data = data_lrt_pop, na.action = na.omit)
# R-squared
yardstick::rsq_trad_vec(truth = mod_length_lines$model$`log10(lines)`, 
                        estimate = mod_length_lines$fitted.values)
# Prediction
10^(mod_length_lines$coefficients[1] + (mod_length_lines$coefficients[2] * log10(20)))

# Stations vs Lines --------------------------------
# Plot
plot_lines_stations <- data_lrt_pop %>% 
  # plot
  ggplot() +
  # points
  geom_point(mapping = aes(x = lines, y = stations), size = 2, 
             alpha = 0.8, colour = "firebrick") +
  geom_smooth(mapping = aes(x = lines, y = stations), linewidth = 1,
              colour = "dodgerblue", alpha = 0.2, fill = "dodgerblue", 
              method = "lm") +
  # Scales
  scale_x_continuous(name = "Lines", 
                     expand = expansion(mult = c(0.01, 0.01)), trans = "log10") +
  scale_y_continuous(name = "Stations", 
                     expand = expansion(mult = c(0.01, 0.01)), trans = "log10") +
  # Labels
  labs(title = "Stations vs Lines") +
  theme_vaw_dark()
# Show plot
plot_lines_stations
# Model Length vs Stations
mod_lines_stations <- lm(formula = log10(stations) ~ log10(lines), 
                          data = data_lrt_pop, na.action = na.omit)
# R-squared
yardstick::rsq_trad_vec(truth = mod_lines_stations$model$`log10(stations)`, 
                        estimate = mod_lines_stations$fitted.values)
# Prediction
10^(mod_lines_stations$coefficients[1] + (mod_lines_stations$coefficients[2] * log10(2)))

# Population vs Length -------------------------------
# Plot
plot_popn_length <- data_lrt_pop %>% 
  # plot
  ggplot() +
  # points
  geom_point(mapping = aes(x = popn, y = length), size = 2, 
             alpha = 0.8, colour = "firebrick") +
  geom_smooth(mapping = aes(x = popn, y = length), linewidth = 1,
              colour = "dodgerblue", alpha = 0.2, fill = "dodgerblue", 
              method = "lm") +
  # Ab line at Kalyani popun
  geom_vline(mapping = aes(xintercept = 1.5e+5), colour = "white", alpha = 0.7, linetype = "dashed") +
  # Scales
  scale_x_continuous(name = "Population", 
                     labels = label_comma(scale = 1e-5, suffix = "L", accuracy = 0.1),
                     expand = expansion(mult = c(0.01, 0.01)), trans = "log10") +
  scale_y_continuous(name = "Route Length (km)", 
                     expand = expansion(mult = c(0.01, 0.01)), trans = "log10") +
  # Labels
  labs(title = "Route Length vs Population") +
  theme_vaw_dark()
# Show plot
plot_popn_length
# Model Length vs Stations
mod_popn_length <- lm(formula = log10(length) ~ log10(popn), 
                          data = data_lrt_pop, na.action = na.omit)
# R-squared
yardstick::rsq_trad_vec(truth = mod_popn_length$model$`log10(length)`, 
                        estimate = mod_popn_length$fitted.values)
# Prediction
10^(mod_popn_length$coefficients[1] + (mod_popn_length$coefficients[2] * log10(1.5e+5)))


# Population vs Stations -------------------------------
# Plot
plot_popn_stations <- data_lrt_pop %>% 
  # plot
  ggplot() +
  # points
  geom_point(mapping = aes(x = popn, y = stations), size = 2, 
             alpha = 0.8, colour = "firebrick") +
  geom_smooth(mapping = aes(x = popn, y = stations), linewidth = 1,
              colour = "dodgerblue", alpha = 0.2, fill = "dodgerblue", 
              method = "lm") +
  # Scales
  scale_x_continuous(name = "Population", 
                     labels = label_comma(scale = 1e-5, suffix = "L", accuracy = 0.1),
                     expand = expansion(mult = c(0.01, 0.01)), trans = "log10") +
  scale_y_continuous(name = "Stations", 
                     expand = expansion(mult = c(0.01, 0.01)), trans = "log10") +
  # Labels
  labs(title = "Stations vs Population") +
  theme_vaw_dark()
# Show plot
plot_popn_stations
# Model stations vs Stations
mod_popn_stations <- lm(formula = log10(stations) ~ log10(popn), 
                          data = data_lrt_pop, na.action = na.omit)
# R-squared
yardstick::rsq_trad_vec(truth = mod_popn_stations$model$`log10(stations)`, 
                        estimate = mod_popn_stations$fitted.values)
# Prediction
10^(mod_popn_stations$coefficients[1] + (mod_popn_stations$coefficients[2] * log10(1e+5)))

# Population vs Lines -------------------------------
# Plot
plot_popn_lines <- data_lrt_pop %>% 
  # plot
  ggplot() +
  # points
  geom_point(mapping = aes(x = popn, y = lines), size = 2, 
             alpha = 0.8, colour = "firebrick") +
  geom_smooth(mapping = aes(x = popn, y = lines), linewidth = 1,
              colour = "dodgerblue", alpha = 0.2, fill = "dodgerblue", 
              method = "lm") +
  # Scales
  scale_x_continuous(name = "Population", 
                     labels = label_comma(scale = 1e-5, suffix = "L", accuracy = 0.1),
                     expand = expansion(mult = c(0.01, 0.01)), trans = "log10") +
  scale_y_continuous(name = "Lines", 
                     expand = expansion(mult = c(0.01, 0.01)), trans = "log10") +
  # Labels
  labs(title = "Lines vs Population") +
  theme_vaw_dark()
# Show plot
plot_popn_lines
# Model lines vs lines
mod_popn_lines <- lm(formula = log10(lines) ~ log10(popn), 
                          data = data_lrt_pop, na.action = na.omit)
# R-squared
yardstick::rsq_trad_vec(truth = mod_popn_lines$model$`log10(lines)`, 
                        estimate = mod_popn_lines$fitted.values)
# Prediction
10^(mod_popn_lines$coefficients[1] + (mod_popn_lines$coefficients[2] * log10(1e+5)))
```

## Get Population and Topographical Features
```{r Population and Topology}
# Fetch city municipality limits -----------------------
sf_city_limits <- st_read(dsn = "kalyani_wb_municipality_limits.kml") %>% 
  st_zm()

# Create bbox for city limits ----------------------
sf_bbox <- st_bbox(sf_city_limits) %>% 
  # Convert to sf
  st_as_sfc(crs = st_crs(sf_city_limits))

# Fetch road network of city --------------------------
# # Get main roads
# feat_major_road <- opq(bbox = sf_bbox, timeout = 100) %>%
#   add_osm_feature(key = "highway",
#                   value = c("motorway", "motorway_link",
#                             "trunk", "trunk_link",
#                             "primary", "primary_link",
#                             "secondary", "secondary_link",
#                             "tertiary", "tertiary_link",
#                             "unclassified", "residential")) %>%
#   osmdata_sf()
# # # Save
# write_rds(x = feat_major_road, file = "kalyani_road.rds")
feat_major_road <- read_rds(file = "kalyani_road.rds")

# Create sf object combining lines and polygons ----------------------------
sf_city_road <- bind_rows(feat_major_road$osm_lines %>% 
                            select(osm_id, highway),
                          feat_major_road$osm_polygons %>% 
                            select(osm_id, highway) %>% 
                            st_cast(to = "LINESTRING")) %>% 
  # Truncate roads to stay within bounding box
  st_intersection(y = sf_city_limits)

# Load Population raster ------------------------------
rs_popn <- rast(x = "GHS_POP_E2025_GLOBE_R2023A_54009_100_V1_0_R7_C27.tif") %>% 
  # Remove layers
  tidyterra::rename(popn = GHS_POP_E2025_GLOBE_R2023A_54009_100_V1_0_R7_C27) %>% 
  # Crop to city bounding box
  crop(y = vect(x = sf_bbox %>% 
                                st_transform(crs = "+proj=moll +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84 +units=m"))) %>% 
  # Change projection
  project(y = "epsg:4326") %>% 
  # Mask values outside city limits
  mask(mask = sf_city_limits, inverse = FALSE, updatevalue = NA) %>% 
  # The high population area is incorrect, change values
  tidyterra::mutate(popn = case_when(popn >= 270 ~ 100, TRUE ~ popn))
# Write to disk
# terra::writeRaster(x = rs_popn, filename = "raster_city_popn.tif", overwrite = TRUE)

# # Load built up surface raster ------------------------------
# # To be used as proxy for population, since is has higher resolution
# rs_built <- terra::rast(x = "GHS_BUILT_S_E2018_GLOBE_R2023A_54009_10_V1_0_R7_C27.tif")  %>% 
#   `c`(terra::rast(x = "GHS_BUILT_S_NRES_E2018_GLOBE_R2023A_54009_10_V1_0_R7_C27.tif")) %>% 
#   # Rename layers
#   tidyterra::rename(total = GHS_BUILT_S_E2018_GLOBE_R2023A_54009_10_V1_0_R7_C27,
#                     nres = GHS_BUILT_S_NRES_E2018_GLOBE_R2023A_54009_10_V1_0_R7_C27) %>% 
#   # Crop to city bounding box
#   terra::crop(y = terra::vect(x = bbox_polygon %>% 
#                                 st_transform(crs = "+proj=moll +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84 +units=m"))) %>% 
#   # Calculate residential surface
#   tidyterra::mutate(nres = nres * 100,
#                     res = total - nres,
#                     # recode some values
#                     res = case_when(res < 0 ~ 0, TRUE ~ res)) %>% 
#   # Remove non res and total layers
#   select(-c(total, nres)) %>% 
#   # Change projection
#   terra::project(y = "epsg:4326")

# Create list of Demand Generator points  ---------------------------------
# These generate travel demand apart from the resident population
sf_demand_point <- tribble(
  ~point_name, ~demand, ~lat, ~lon,
    "Kalyani Railway Station", 50000, 22.96929, 88.46738, # based on the fact that KYI is SG-2
    "Kalyani Silpanchal Railway Station", 5000, 22.97625, 88.45643,
    "Kalyani Ghoshpara Railway Station", 8000, 22.98163, 88.43940,
    "Kalyani Simanta Railway Station", 3000, 22.98747, 88.42793,
    "JNM Hospital", 10000, 22.97359, 88.45592,
    "Vidyasagar Manch", 1000, 22.97090, 88.46263,
    "Kalyani Lake Park", 1000, 22.97273, 88.44338,
    "Kalyani ITI More", 5000, 22.98010, 88.43795,
    "Kalyani Central Park", 5000, 22.97554, 88.43496,
    "Buddha Park More", 3000, 22.96325, 88.42791,
    "Kalyani Stadium", 10000, 22.97496, 88.44936,
    "Kalyani Municipality", 2000, 22.97693, 88.44724,
    "A-2 Market", 5000, 22.97335, 88.46369,
    "A-11 Market", 3000, 22.96443, 88.45425,
    "B-8 Market", 5000, 22.98277, 88.4328,
    "B-11 Market", 3000, 22.97599, 88.44339,
    "Kalyani University", 2000, 22.98567, 88.4455,
    "JIS College", 5000, 22.95954, 88.44801,
    "Springdale School", 2000, 22.97733, 88.45174,
    "Kalyani Experimental School", 2000, 22.97814, 88.44438,
    "Pannalal School", 1000, 22.97349, 88.43875,
    "Central Model School", 1000, 22.96927, 88.43008,
    "Bidhan Girls School", 1000, 22.97827, 88.42866,
    "Julien Day School", 1000, 22.96361, 88.45992) %>% 
  # Convert to sf
  st_as_sf(coords = c("lon", "lat"), crs = st_crs(sf_bbox))

# ggplot() +
#   tidyterra::geom_spatraster(data = rs_popn, aes(fill = popn)) +
#   tidyterra::geom_spatraster(data = rs_popn_station, aes(fill = popn)) +
#   geom_sf(data = sf_city_road) +
#   geom_sf(data = vc_station, size = 3, colour = "red") +
#   scale_fill_viridis_b()
```

## Workflow
- Get road network
- Fetch population raster
- Define Point Generators of demand
- Set number of stations and lines
- Create random set of points as stations
- Create distance matrix from points to each cell in raster
- Create distance matrix from points to point demand generators
- Calculate objective function value
- Run optimization algorithm

```{r Objective Function for Station Locations}
# From linear regression, we get values of length, lines and stations -----------
# Length - 20km | 30km
# Stations - 30 | 45
# Lines - 2 | 3

# Set system parameters ------------------
param_n_station <- 30
param_n_line <- 2
param_sd_sat_dist <- 400

# Define function to calculate population served by each station --------------------
fx_popn_served <- function(sf_station_point){
  # sf_station_point = sf_station$geometry[1]
  # Calculate population
  popn_serve_station <- sf_station_point %>%
    # Convert to sf object
    st_sfc(crs = st_crs(sf_genome_station)) %>% 
    # Convert to Spat Vector
    vect() %>% 
    terra::distance(x = rs_popn, y = .) %>% 
    # Calculate population satisfied by each station, first calculate multiplier for each cell
    tidyterra::mutate(popn = exp(-(popn^2)/(param_sd_sat_dist^2))) %>%
    # Multiply with the actual population in each
    `*`(rs_popn) %>%
    # Calculate total sum
    terra::global("sum", na.rm = TRUE) %>%
    unlist(use.names = FALSE)
  
  return(round(popn_serve_station))
}

# Define sample station points ---------------------
sf_genome_station <- st_sample(x = sf_city_limits, size = param_n_station) %>% 
  # Convert to sf
  st_sf(geometry = .) %>% 
  # Set index number
  mutate(station_index = row_number())

fgh <- sf_genome_station %>% st_coordinates() %>% t() %>% as.vector()

# Calculate share of point demand generators served by point generators ----------------------
sf_station_point_served <- sf_genome_station %>% 
  # Calculate distance to each point point generator
  st_distance(y = sf_demand_point, by_element = FALSE) %>% 
  # Convert to matrix
  as.matrix() %>% 
  # Drop units due to matrix operations being hampered when sf is loaded
  units::drop_units() %>% 
  # Calculate multiplier for demand based on distance
  (function(a) exp(-(a^2)/(param_sd_sat_dist^2))) %>%
  # Multiply by demand generated  by each point
  `%*%` (sf_demand_point$demand) %>% 
  as.data.frame() %>% 
  # Convert to tibble
  as_tibble() %>% 
  rename(generator_popn_served = V1) %>% 
  # Round figure
  mutate(generator_popn_served = round(generator_popn_served))

# Calculate share of resident population served by stations ------------------
data_station_popn_served <- sf_genome_station %>% 
  # Apply function
  mutate(popn_served = map_dbl(.x = geometry, 
                               .f = fx_popn_served, .progress = TRUE)) %>% 
  # Map Point generator fields
  bind_cols(sf_station_point_served)

# Calculate total popn served -------------------------------------
sc_total_popn_served <- data_station_popn_served %>% 
  # Add up both types of popn served for each station
  mutate(total_popn = popn_served + generator_popn_served) %>% 
  # Sum up to get total popn
  as_tibble() %>% 
  select(total_popn) %>% 
  sum()

# Create function for Population Initiation -------------------------
fx_ga_init_popn <- function(obj_ga){
  # popn_size <- 200
  # Create population matrix
  mtx_popn <- tibble(indiv_index = 1:obj_ga@popSize) %>% 
    # Create sf vector of sample points for each individual
    mutate(sf_sample = map(.x = indiv_index, .f = function(x){
      # Generate samples for eaqch individual
      st_sample(x = sf_city_limits, size = param_n_station) %>% 
        # Convert to coordinates and create a vector in the form of Lon1, Lat1, Lon2, Lat2, etc
        st_coordinates() %>% t() %>% as.vector()
    }, .progress = TRUE)) %>% 
    # Remove list column
    unnest(cols = sf_sample) %>% 
    # Assign column names
    group_by(indiv_index) %>% 
    mutate(col_name = row_number()) %>% 
    ungroup() %>% 
    # Wide form
    pivot_wider(id_cols = indiv_index, names_from = col_name, values_from = sf_sample) %>% 
    # Convert to matrix
    select(-indiv_index) %>% 
    as.matrix()
  
  return(mtx_popn)
}

# Create function for Population Selection --------------------------
fx_ga_select_popn <- function(obj_ga){
  # Extract fitness value of current generation
  ga_curr_fitness <- obj_ga@fitness
  # Assign probabilities to each individual, proportional to the fitness value
  curr_probs <- ga_curr_fitness/sum(ga_curr_fitness)
  # Select indices of individuals from population, but based on their fitness
  popn_sel <- sample(x = 1:obj_ga@popSize, size = obj_ga@popSize, 
                     replace = TRUE, prob = curr_probs)
  
  # Select individuals from population\
  mtx_popn_select <- obj_ga@population[popn_sel, , drop = FALSE]
  vec_popn_fitness <- obj_ga@fitness[popn_sel]
  
  return(list(population = mtx_popn_select, fitness = vec_popn_fitness))
}

# 

# Create GA function ------------------------------------------
obj_ga_station <- ga(type = "real-valued", fitness = fx_ga_fitness, 
                     population = fx_ga_popn, selection = fx_ga_select, 
                     crossover = fx_ga_cross, mutation = fx_ga_mutate, 
                     popSize = 200, pcrossover = 0.8, pmutation = 0.01, 
                     elitism = max(1, round(popSize * 0.03)), maxiter = 1000, 
                     run = 100)

  




```


